# uber-taxi

网约车项目复杂版

## 乘客端

1. 发送验证码：三档验证，防止恶意发送短信。
2. 登录/注册
3. 查看开通区域：高德围栏
4. 预估价格：根据起点终点计算大概费用。
5. 下单
6. 支付：分布式事务。
7. 评价

## 司机端

1. 发送验证码
2. 登录/注册
3. 查看、改变司机状态
4. 司机抢单：分布式锁。
5. 订单状态变更：接到乘客、到达目的地等。
6. 发起收款

## boss端

运营相关。

## 微服务设计原则

架构、模式、拆分、隔离。

目标：隔离系统的变化点。

### 具体原则

高内聚，低耦合。

服务之间高度自治：开发、测试、构建、运行、发布。(无状态)

以业务为中心。

弹性设计：容错、隔离、降级

自动化：持续集成、持续交互。

粒度把控：没有标准。但是，没任何一个服务，不能因为自己的开发和维护，影响到其他服务。

*AKF*：
- x轴，水平复制：运行同一个服务的多个实例，并提供负载均衡，来提高并发能力。
- y轴，业务拆分：将一个服务中的不同部分拆分成为微服务，来提高并发能力。
- z轴，数据分片：将同一类数据分散在不同的服务器上。

## 服务流程展示

用户请求 -> nginx集群 -> 网关(zuul/gateway) -> api-xxx -> service-xxx

用户请求先发送到nginx集群，然后到达网关，网关将请求路由至对应的api上。

## Eureka琐碎知识

集群：如果启动两个eureka服务实例来组成集群，则两个的defaultZone中都只需要写对方的url即可；如果是多个实例来组成集群，就需要将所有的实力的url都定义在defaultZone中

eureka分为服务器端和客户端，都需要导入对应的依赖，以及在YML文件中配置服务名称和eureka服务器的访问地址url。对于服务端，需要在启动类上手动添加@EnableEurekaServer注解。
这样在启动时，就会将当前的项目作为eureka服务器；客户端只需要导入依赖，并配置服务器地址就能够自动被注册，无需其他操作。

为什么eureka是ap。

三级缓存


## Eureka优化
自我保护

自我保护阈值

剔除服务时间间隔

关闭从readOnly读注册表

readWrite和readOnly同步时间间隔

服务下线是，先停服，再手动下线。因为，eureka每过30s就会自动续约一次，如果续约时服务没有实例，就会创建一个。

snapshot快照版本，生产中不能使用。使用了之后，服务器中的jar包有更新，就会拉取，即使没有经过测试。

